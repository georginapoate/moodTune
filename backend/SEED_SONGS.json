Backend-ul aplicației a fost dezvoltat folosind Node.js și framework-ul Express.js, având rolul de a gestiona logica de business, comunicarea cu API-urile externe (Spotify, OpenAI) și persistența datelor într-o bază de date MongoDB. Arhitectura este modulară, separând responsabilitățile în rute, controlere, servicii și middleware, pentru a asigura o mentenanță ușoară și o scalabilitate eficientă.
5.3.1 Fluxul de Autentificare și Managementul Sesiunii
Un aspect fundamental al aplicației este gestionarea identității utilizatorilor. Pentru a oferi o experiență fluidă și sigură, am implementat un sistem de autentificare hibrid, care a evoluat pe parcursul dezvoltării.
Faza 1: Autentificarea inițială prin Spotify
Inițial, pentru a interacționa cu datele unui utilizator și pentru a crea playlist-uri în contul său, am ales să folosim fluxul standard de autorizare oferit de Spotify, cunoscut ca OAuth 2.0 Authorization Code Flow. Această abordare este standardul industriei pentru delegarea accesului și oferă un nivel înalt de securitate, deoarece datele de autentificare ale utilizatorului (parola) nu sunt niciodată expuse aplicației noastre.
Pentru a activa acest flux, a fost necesară configurarea aplicației în Spotify Developer Dashboard, de unde am obținut un Client ID și un Client Secret. De asemenea, am înregistrat o adresă Redirect URI (ex: http://127.0.0.1:5001/api/auth/callback), care reprezintă endpoint-ul de pe serverul nostru unde Spotify va trimite utilizatorul după o autentificare reușită.
Schema fluxului de autorizare Spotify:
[Utilizator] -> Apasă butonul "Login with Spotify" pe frontend.
[Frontend] -> Redirecționează către endpoint-ul backend-ului: GET /api/auth/login.
[Backend - authController.js:spotifyLogin] -> Construiește URL-ul de autorizare Spotify (incluzând Client ID, scopes și Redirect URI) și redirecționează browser-ul utilizatorului către pagina de autentificare Spotify.
[Utilizator] -> Se autentifică pe site-ul Spotify și autorizează permisiunile cerute de aplicație (definite în variabila scopes).
[Spotify] -> Redirecționează utilizatorul înapoi la Redirect URI-ul specificat (GET /api/auth/callback), adăugând un authorization_code temporar ca parametru în URL.
[Backend - authController.js:spotifyCallback] -> Primește authorization_code. Folosind acest cod, împreună cu Client ID și Client Secret, face o cerere server-to-server către Spotify pentru a obține un Access Token și un Refresh Token.
În acest punct, fluxul inițial se încheia. Access Token-ul permitea aplicației să facă cereri către API-ul Spotify în numele utilizatorului.
Faza 2: Evoluția sistemului – Introducerea JWT pentru sesiuni locale
Pe măsură ce aplicația a evoluat, a apărut nevoia de a salva date specifice utilizatorului, precum istoricul prompt-urilor și playlist-urile generate, într-o bază de date locală (MongoDB). Fluxul de autentificare Spotify, deși excelent pentru a obține identitatea și permisiunile, nu era suficient pentru a gestiona o sesiune persistentă și securizată cu propriul nostru backend.
Pentru a rezolva această problemă, am extins fluxul de autentificare. Am continuat să folosim Spotify ca furnizor de identitate, dar am adăugat un sistem propriu de management al sesiunii folosind JSON Web Tokens (JWT).
Schema fluxului de autentificare final (hibrid):
Pașii 1-5 rămân identici. Fluxul continuă de la pasul 6:
[Backend - authController.js:spotifyCallback] -> Primește authorization_code și îl schimbă pentru Access Token și Refresh Token de la Spotify.
[Backend - spotifyService.js, dbService.js] -> Folosind Access Token-ul, backend-ul face o cerere la endpoint-ul /v1/me al API-ului Spotify pentru a obține profilul utilizatorului.
[Backend - dbService.js:findOrCreateUser] -> Caută utilizatorul în baza de date locală MongoDB după spotifyId.
Dacă utilizatorul există, îi actualizează token-urile Spotify (care sunt criptate înainte de salvare).
Dacă nu există, creează o nouă intrare în colecția users cu datele de profil primite.
[Backend - authController.js:spotifyCallback] -> Generează un JWT care conține ID-ul intern al utilizatorului din baza noastră de date (ex: { userId: '...' }). Acest token este semnat digital cu un secret (JWT_SECRET) pentru a-i garanta integritatea.
[Backend] -> Setează acest JWT într-un cookie securizat, de tip httpOnly, numit auth_token. Acest flag previne accesarea cookie-ului prin JavaScript pe client, protejând împotriva atacurilor de tip XSS.
[Backend] -> Redirecționează browser-ul utilizatorului înapoi la aplicația frontend (http://127.0.0.1:3000/).
Managementul sesiunilor și protejarea rutelor
După acest flux, de fiecare dată când frontend-ul face o cerere către rutele protejate ale backend-ului (ex: /api/users/me, /api/playlist/generate), browser-ul va atașa automat cookie-ul auth_token.
Am implementat un middleware numit protect (middleware/authMiddleware.js), care este aplicat pe toate rutele ce necesită autentificare.
Funcționarea middleware-ului protect:
Extrage token-ul JWT din cookie-ul auth_token.
Verifică semnătura token-ului folosind JWT_SECRET.
Dacă token-ul este valid, extrage userId și îl atașează obiectului request (ex: req.userId). Astfel, controlerele ulterioare știu exact cine face cererea.
Dacă token-ul lipsește sau este invalid, middleware-ul returnează o eroare 401 Unauthorized, blocând accesul la resursa protejată.
Acest sistem hibrid oferă ce e mai bun din ambele lumi: securitatea și încrederea unui furnizor de identitate consacrat precum Spotify și flexibilitatea de a gestiona sesiuni și date specifice aplicației noastre într-un mod eficient și sigur.